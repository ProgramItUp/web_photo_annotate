<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Annotation Tool</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Custom CSS -->
    <style>
        .canvas-container {
            position: relative;
            margin: 20px 0;
            border: 1px solid #ccc;
            overflow: hidden;
        }
        #image-container {
            min-height: 400px;
            background-color: #f8f9fa;
        }
        .tool-selected {
            background-color: #0d6efd !important;
            color: white !important;
        }
        .controls-panel {
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            margin-bottom: 15px;
        }
        .coordinates-display {
            font-family: monospace;
            padding: 8px;
            background-color: #f1f1f1;
            border-radius: 4px;
        }
        .recording-indicator {
            color: red;
            font-weight: bold;
            display: none;
        }
        .audio-volume-meter {
            width: 100%;
            height: 20px;
            background-color: #f1f1f1;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }
        .volume-level {
            height: 100%;
            background-color: #28a745;
            width: 0%;
            transition: width 0.1s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="container mt-4">
        <h1 class="mb-4">Image Annotation Tool</h1>
        
        <!-- Image Loading Section -->
        <div class="card mb-3">
            <div class="card-header">Load Image</div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="local-image" class="form-label">Load from local file:</label>
                            <input type="file" class="form-control" id="local-image" accept="image/*">
                        </div>
                    </div>
                    <div class="col-md-6">
                        <div class="mb-3">
                            <label for="url-image" class="form-label">Load from URL:</label>
                            <div class="input-group">
                                <input type="text" class="form-control" id="url-image" placeholder="https://example.com/image.jpg">
                                <button class="btn btn-primary" id="load-url-btn">Load</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Image and Drawing Area -->
        <div class="row">
            <div class="col-md-9">
                <div class="canvas-container" id="image-container">
                    <canvas id="canvas"></canvas>
                </div>
                <div class="coordinates-display mb-2" id="coordinates">Mouse: X: 0, Y: 0</div>
                <div class="alert alert-info small">
                    <strong>Navigation:</strong> Pan with Ctrl+click and drag, Zoom with mouse wheel
                </div>
            </div>
            
            <!-- Controls Section -->
            <div class="col-md-3">
                <!-- Image Adjustment Controls -->
                <div class="controls-panel">
                    <h5>Image Adjustments</h5>
                    <div class="mb-3">
                        <label for="brightness" class="form-label">Brightness</label>
                        <input type="range" class="form-range" id="brightness" min="-100" max="100" value="0">
                    </div>
                    <div class="mb-3">
                        <label for="contrast" class="form-label">Contrast</label>
                        <input type="range" class="form-range" id="contrast" min="-100" max="100" value="0">
                    </div>
                    <div class="mb-3">
                        <label for="cursor-size" class="form-label">Cursor Size</label>
                        <input type="range" class="form-range" id="cursor-size" min="1" max="50" value="10">
                    </div>
                    <div class="mb-3">
                        <label class="form-check-label">
                            <input type="checkbox" class="form-check-input" id="cursor-tail-toggle">
                            Show cursor trail
                        </label>
                    </div>
                </div>
                
                <!-- Drawing Tools -->
                <div class="controls-panel">
                    <h5>Drawing Tools</h5>
                    <div class="btn-group w-100 mb-3" role="group">
                        <button type="button" class="btn btn-outline-primary" id="tool-select">Select</button>
                        <button type="button" class="btn btn-outline-primary" id="tool-dot">Dot</button>
                        <button type="button" class="btn btn-outline-primary" id="tool-box">Box</button>
                        <button type="button" class="btn btn-outline-primary" id="tool-circle">Circle</button>
                    </div>
                    <div class="btn-group w-100 mb-3" role="group">
                        <button type="button" class="btn btn-outline-primary" id="tool-squiggle">Squiggle</button>
                        <button type="button" class="btn btn-outline-primary" id="tool-arrow">Arrow</button>
                        <button type="button" class="btn btn-outline-danger" id="delete-selected">Delete</button>
                    </div>
                </div>
                
                <!-- Audio Recording -->
                <div class="controls-panel">
                    <h5>Audio Recording</h5>
                    <button class="btn btn-danger w-100 mb-2" id="record-btn">Start Recording</button>
                    <button class="btn btn-warning w-100 mb-2" id="pause-btn" disabled>Pause Recording</button>
                    <div class="d-flex align-items-center">
                        <span class="recording-indicator" id="recording-indicator">‚óè Recording</span>
                        <span class="ms-auto recording-indicator" id="recording-timer">00:00</span>
                    </div>
                    <div class="audio-volume-meter" id="volume-meter">
                        <div class="volume-level" id="volume-level"></div>
                    </div>
                </div>
                
                <!-- File Operations -->
                <div class="controls-panel">
                    <h5>File Operations</h5>
                    <button class="btn btn-success w-100 mb-2" id="save-btn">Save Annotation Data</button>
                    <button class="btn btn-primary w-100 mb-2" id="email-btn">Email Annotation Data</button>
                    <button class="btn btn-info w-100 mb-2" id="load-btn">Load Annotation Data</button>
                    <input type="file" class="form-control d-none" id="load-file" accept=".json">
                    <button class="btn btn-warning w-100" id="replay-btn">Replay Recording</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Log Area -->
    <div class="container mb-4">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>Log Messages</span>
                <button class="btn btn-sm btn-outline-secondary" id="clear-log">Clear</button>
            </div>
            <div class="card-body">
                <textarea id="log-area" class="form-control" rows="6" readonly style="font-family: monospace; font-size: 0.875rem;"></textarea>
            </div>
        </div>
    </div>

    <!-- Email Modal -->
    <div class="modal fade" id="emailModal" tabindex="-1" aria-labelledby="emailModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="emailModalLabel">Send Annotation Data via Email</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="email-address" class="form-label">Email Address</label>
                        <input type="email" class="form-control" id="email-address" placeholder="your@email.com">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="send-email-btn">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/recordrtc@5.6.2/RecordRTC.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/emailjs-com@3.2.0/dist/email.min.js"></script>
    
    <script>
        // Initialize variables
        let canvas;
        let recorder;
        let mouseTrackingInterval;
        let mouseData = [];
        let audioBlob = null;
        let currentTool = 'select';
        let isRecording = false;
        let isPaused = false;
        let cursorSize = 10;
        let brightnessValue = 0;
        let contrastValue = 0;
        let emailModal;
        let isPanning = false;
        let lastPosX;
        let lastPosY;
        let zoomLevel = 1;
        let showCursorTail = false;
        let cursorTrailPoints = [];
        let audioContext;
        let audioStream;
        let recordingStartTime;
        let recordingTimer;
        let pausedTime = 0;
        let pauseStartTime = 0;

        // Function to log messages
        function logMessage(message) {
            const logArea = document.getElementById('log-area');
            const timestamp = new Date().toISOString().split('T')[1].slice(0, -1);
            logArea.value += `[${timestamp}] ${message}\n`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        // Initialize on document load
        document.addEventListener('DOMContentLoaded', function() {
            // Setup canvas
            canvas = new fabric.Canvas('canvas', {
                width: document.getElementById('image-container').offsetWidth,
                height: 400,
                selection: true,
                preserveObjectStacking: true // Keep objects stacked in the order they were added
            });

            // Initialize email modal
            emailModal = new bootstrap.Modal(document.getElementById('emailModal'));

            // Setup event listeners
            setupEventListeners();
            
            logMessage('Application initialized');
        });

        function setupEventListeners() {
            // Image loading
            document.getElementById('local-image').addEventListener('change', loadLocalImage);
            document.getElementById('load-url-btn').addEventListener('click', loadUrlImage);
            
            // Image adjustments
            document.getElementById('brightness').addEventListener('input', updateImageFilters);
            document.getElementById('contrast').addEventListener('input', updateImageFilters);
            document.getElementById('cursor-size').addEventListener('input', updateCursorSize);
            document.getElementById('cursor-tail-toggle').addEventListener('change', function() {
                showCursorTail = this.checked;
                logMessage(`Cursor trail ${showCursorTail ? 'enabled' : 'disabled'}`);
            });
            
            // Drawing tools
            document.getElementById('tool-select').addEventListener('click', () => setTool('select'));
            document.getElementById('tool-dot').addEventListener('click', () => setTool('dot'));
            document.getElementById('tool-box').addEventListener('click', () => setTool('box'));
            document.getElementById('tool-circle').addEventListener('click', () => setTool('circle'));
            document.getElementById('tool-squiggle').addEventListener('click', () => setTool('squiggle'));
            document.getElementById('tool-arrow').addEventListener('click', () => setTool('arrow'));
            document.getElementById('delete-selected').addEventListener('click', deleteSelected);
            
            // Audio recording
            document.getElementById('record-btn').addEventListener('click', toggleRecording);
            document.getElementById('pause-btn').addEventListener('click', pauseResumeRecording);
            
            // File operations
            document.getElementById('save-btn').addEventListener('click', saveAnnotationData);
            document.getElementById('email-btn').addEventListener('click', showEmailModal);
            document.getElementById('load-btn').addEventListener('click', () => document.getElementById('load-file').click());
            document.getElementById('load-file').addEventListener('change', loadAnnotationData);
            document.getElementById('replay-btn').addEventListener('click', replayRecording);
            document.getElementById('send-email-btn').addEventListener('click', sendEmail);
            
            // Log area
            document.getElementById('clear-log').addEventListener('click', function() {
                document.getElementById('log-area').value = '';
                logMessage('Log cleared');
            });
            
            // Mouse tracking on canvas
            canvas.on('mouse:move', updateCoordinates);
            
            // Setup Pan and Zoom handlers
            setupPanZoomHandlers();
            
            // Set select tool as default
            setTool('select');
            
            // Track window resize
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            canvas.setWidth(document.getElementById('image-container').offsetWidth);
            canvas.renderAll();
        }

        function loadLocalImage(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    loadImageToCanvas(event.target.result);
                    logMessage(`Loaded image from file: ${file.name}`);
                };
                reader.readAsDataURL(file);
            }
        }

        function loadUrlImage() {
            const url = document.getElementById('url-image').value;
            if (url) {
                loadImageToCanvas(url);
                logMessage(`Loaded image from URL: ${url}`);
            }
        }

        function loadImageToCanvas(src) {
            fabric.Image.fromURL(src, function(img) {
                // Clear canvas
                canvas.clear();
                cursorTrailPoints = [];
                
                // Scale image to fit canvas while maintaining aspect ratio
                const canvasWidth = canvas.getWidth();
                const canvasHeight = canvas.getHeight();
                
                if (img.width > canvasWidth || img.height > canvasHeight) {
                    const scaleFactor = Math.min(
                        canvasWidth / img.width,
                        canvasHeight / img.height
                    );
                    img.scale(scaleFactor);
                }
                
                // Set image as the background
                img.selectable = false;
                
                // Ensure image is at the bottom layer
                canvas.add(img);
                img.sendToBack();
                
                // Reset zoom and pan
                canvas.setZoom(1);
                zoomLevel = 1;
                
                // Reset filters
                brightnessValue = 0;
                contrastValue = 0;
                document.getElementById('brightness').value = 0;
                document.getElementById('contrast').value = 0;
                
                canvas.renderAll();
            });
        }

        function updateImageFilters() {
            brightnessValue = parseInt(document.getElementById('brightness').value);
            contrastValue = parseInt(document.getElementById('contrast').value);
            
            const objects = canvas.getObjects();
            // Find the image object (usually the first/bottom object)
            const imgObject = objects.find(obj => obj.type === 'image');
            
            if (imgObject) {
                // Remove existing filters
                imgObject.filters = [];
                
                // Add brightness filter if needed
                if (brightnessValue !== 0) {
                    imgObject.filters.push(new fabric.Image.filters.Brightness({
                        brightness: brightnessValue / 100
                    }));
                }
                
                // Add contrast filter if needed
                if (contrastValue !== 0) {
                    imgObject.filters.push(new fabric.Image.filters.Contrast({
                        contrast: contrastValue / 100
                    }));
                }
                
                // Apply filters
                imgObject.applyFilters();
                canvas.renderAll();
            }
        }

        function updateCursorSize() {
            cursorSize = parseInt(document.getElementById('cursor-size').value);
            
            // Update cursor trail if it exists
            if (canvas.getActiveObject() && canvas.getActiveObject().type === 'circle' && canvas.getActiveObject().id === 'cursor') {
                canvas.getActiveObject().set({
                    radius: cursorSize / 2
                });
                canvas.renderAll();
            }
        }

        function setTool(tool) {
            currentTool = tool;
            
            // Update UI
            const toolButtons = document.querySelectorAll('[id^="tool-"]');
            toolButtons.forEach(button => {
                button.classList.remove('tool-selected');
            });
            document.getElementById(`tool-${tool}`).classList.add('tool-selected');
            
            // Remove previous drawing event handlers
            canvas.off('mouse:down');
            canvas.off('mouse:move');
            canvas.off('mouse:up');
            
            // Add panning event handlers
            setupPanZoomHandlers();
            
            logMessage(`Tool switched to: ${tool}`);
            
            // Set canvas behavior based on tool
            if (tool === 'select') {
                canvas.isDrawingMode = false;
                canvas.selection = true;
            } else if (tool === 'dot') {
                canvas.isDrawingMode = false;
                canvas.selection = false;
                
                // Setup dot placement on click
                canvas.on('mouse:down', placeDot);
            } else if (tool === 'squiggle') {
                canvas.isDrawingMode = true;
                canvas.freeDrawingBrush.width = cursorSize;
                canvas.freeDrawingBrush.color = '#000000';
                canvas.selection = false;
            } else {
                canvas.isDrawingMode = false;
                canvas.selection = false;
                
                // Setup drawing handlers for shapes
                canvas.on('mouse:down', startDrawing);
                canvas.on('mouse:move', drawing);
                canvas.on('mouse:up', endDrawing);
            }
        }

        function setupPanZoomHandlers() {
            // Pan with Ctrl+click and drag
            canvas.on('mouse:down', function(opt) {
                if (opt.e.ctrlKey) {
                    isPanning = true;
                    canvas.selection = false;
                    lastPosX = opt.e.clientX;
                    lastPosY = opt.e.clientY;
                    canvas.setCursor('grabbing');
                }
            });
            
            canvas.on('mouse:move', function(opt) {
                if (isPanning && opt.e.ctrlKey) {
                    const deltaX = opt.e.clientX - lastPosX;
                    const deltaY = opt.e.clientY - lastPosY;
                    lastPosX = opt.e.clientX;
                    lastPosY = opt.e.clientY;
                    
                    // Move all objects together
                    const objects = canvas.getObjects();
                    objects.forEach(obj => {
                        obj.left += deltaX;
                        obj.top += deltaY;
                        obj.setCoords();
                    });
                    
                    canvas.renderAll();
                }
            });
            
            canvas.on('mouse:up', function() {
                if (isPanning) {
                    isPanning = false;
                    canvas.selection = true;
                    canvas.setCursor('default');
                }
            });
            
            // Zoom with mouse wheel
            canvas.on('mouse:wheel', function(opt) {
                const delta = opt.e.deltaY;
                let zoom = canvas.getZoom();
                zoom *= 0.999 ** delta;
                
                // Limit zoom level
                if (zoom > 20) zoom = 20;
                if (zoom < 0.1) zoom = 0.1;
                
                zoomLevel = zoom;
                
                // Calculate zoom point (mouse position)
                const point = new fabric.Point(opt.e.offsetX, opt.e.offsetY);
                
                // Apply zoom centered on mouse position
                canvas.zoomToPoint(point, zoom);
                
                opt.e.preventDefault();
                opt.e.stopPropagation();
            });
        }

        let isDrawing = false;
        let drawingObject = null;
        let startPoint = {};

        function startDrawing(options) {
            if (options.e.ctrlKey) return; // Don't draw if ctrl is pressed (panning)
            if (currentTool !== 'box' && currentTool !== 'circle' && currentTool !== 'arrow') return;
            
            isDrawing = true;
            const pointer = canvas.getPointer(options.e);
            startPoint = { x: pointer.x, y: pointer.y };
            
            if (currentTool === 'box') {
                drawingObject = new fabric.Rect({
                    left: pointer.x,
                    top: pointer.y,
                    width: 0,
                    height: 0,
                    stroke: '#000000',
                    strokeWidth: 2,
                    fill: 'rgba(0, 0, 0, 0.1)',
                    selectable: true
                });
            } else if (currentTool === 'circle') {
                drawingObject = new fabric.Circle({
                    left: pointer.x,
                    top: pointer.y,
                    radius: 0,
                    stroke: '#000000',
                    strokeWidth: 2,
                    fill: 'rgba(0, 0, 0, 0.1)',
                    selectable: true
                });
            } else if (currentTool === 'arrow') {
                // For arrow, we'll use a line with an arrow head
                drawingObject = new fabric.Line([pointer.x, pointer.y, pointer.x, pointer.y], {
                    stroke: '#000000',
                    strokeWidth: 2,
                    selectable: true
                });
            }
            
            canvas.add(drawingObject);
            
            // Ensure drawing object is on top
            drawingObject.bringToFront();
        }

        function drawing(options) {
            if (!isDrawing) return;
            if (options.e.ctrlKey) return; // Don't draw if ctrl is pressed (panning)
            
            const pointer = canvas.getPointer(options.e);
            
            if (currentTool === 'box') {
                if (startPoint.x > pointer.x) {
                    drawingObject.set({ left: pointer.x });
                }
                if (startPoint.y > pointer.y) {
                    drawingObject.set({ top: pointer.y });
                }
                
                drawingObject.set({
                    width: Math.abs(startPoint.x - pointer.x),
                    height: Math.abs(startPoint.y - pointer.y)
                });
            } else if (currentTool === 'circle') {
                const radius = Math.sqrt(
                    Math.pow(startPoint.x - pointer.x, 2) +
                    Math.pow(startPoint.y - pointer.y, 2)
                ) / 2;
                
                const centerX = (startPoint.x + pointer.x) / 2;
                const centerY = (startPoint.y + pointer.y) / 2;
                
                drawingObject.set({
                    left: centerX - radius,
                    top: centerY - radius,
                    radius: radius
                });
            } else if (currentTool === 'arrow') {
                drawingObject.set({
                    x2: pointer.x,
                    y2: pointer.y
                });
            }
            
            canvas.renderAll();
        }

        function endDrawing(options) {
            if (!isDrawing) return;
            if (options && options.e.ctrlKey) return; // Don't end drawing if ctrl is pressed (panning)
            
            isDrawing = false;
            
            if (currentTool === 'arrow' && drawingObject) {
                // Add arrow head
                const dx = drawingObject.x2 - drawingObject.x1;
                const dy = drawingObject.y2 - drawingObject.y1;
                const angle = Math.atan2(dy, dx);
                
                const headLength = 15;
                const headAngle = Math.PI / 6; // 30 degrees
                
                const arrowHead1 = new fabric.Line([
                    drawingObject.x2, 
                    drawingObject.y2,
                    drawingObject.x2 - headLength * Math.cos(angle - headAngle),
                    drawingObject.y2 - headLength * Math.sin(angle - headAngle)
                ], {
                    stroke: '#000000',
                    strokeWidth: 2,
                    selectable: false
                });
                
                const arrowHead2 = new fabric.Line([
                    drawingObject.x2, 
                    drawingObject.y2,
                    drawingObject.x2 - headLength * Math.cos(angle + headAngle),
                    drawingObject.y2 - headLength * Math.sin(angle + headAngle)
                ], {
                    stroke: '#000000',
                    strokeWidth: 2,
                    selectable: false
                });
                
                // Group the arrow parts
                const arrowGroup = new fabric.Group([drawingObject, arrowHead1, arrowHead2], {
                    selectable: true
                });
                canvas.remove(drawingObject);
                canvas.add(arrowGroup);
                
                // Ensure arrow is on top
                arrowGroup.bringToFront();
            } else if (drawingObject) {
                // Ensure other shapes are on top
                drawingObject.bringToFront();
            }
            
            drawingObject = null;
            canvas.renderAll();
        }

        function deleteSelected() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.remove(activeObject);
                canvas.renderAll();
            }
        }

        function updateCoordinates(options) {
            if (!options || !options.e) return;
            
            const pointer = canvas.getPointer(options.e);
            const imageCoords = transformCoordinates(pointer);
            document.getElementById('coordinates').textContent = `Mouse: X: ${Math.round(imageCoords.x)}, Y: ${Math.round(imageCoords.y)}`;
            
            // Update cursor trail if enabled
            if (showCursorTail) {
                updateCursorTrail(pointer);
            }
            
            // Record mouse data if tracking is active
            if (isRecording && !isPaused) {
                // We're only adding data 5 times per second, so we don't need to do it on every move
                // This is handled by the interval in toggleRecording()
            }
        }

        function transformCoordinates(pointer) {
            // Transforms canvas coordinates to image coordinates accounting for zoom and pan
            // For simplicity, we'll just return the canvas coordinates for now
            return {
                x: pointer.x,
                y: pointer.y
            };
        }

        function updateCursorTrail(pointer) {
            // Add current point to trail
            cursorTrailPoints.push({
                x: pointer.x,
                y: pointer.y,
                time: Date.now()
            });
            
            // Only keep points from the last 3 seconds
            const threeSecondsAgo = Date.now() - 3000;
            cursorTrailPoints = cursorTrailPoints.filter(point => point.time > threeSecondsAgo);
            
            // Clear existing trail
            const existingTrail = canvas.getObjects().filter(obj => obj.id === 'cursorTrail');
            existingTrail.forEach(obj => canvas.remove(obj));
            
            // Draw trail if we have enough points
            if (cursorTrailPoints.length > 2) {
                const pathData = [];
                
                for (let i = 0; i < cursorTrailPoints.length; i++) {
                    const point = cursorTrailPoints[i];
                    if (i === 0) {
                        pathData.push('M', point.x, point.y);
                    } else {
                        pathData.push('L', point.x, point.y);
                    }
                }
                
                const trail = new fabric.Path(pathData.join(' '), {
                    id: 'cursorTrail',
                    stroke: 'rgba(255, 0, 0, 0.5)',
                    strokeWidth: 2,
                    fill: false,
                    selectable: false,
                    evented: false
                });
                
                canvas.add(trail);
                trail.bringToFront();
            }
        }

        function toggleRecording() {
            const recordBtn = document.getElementById('record-btn');
            const pauseBtn = document.getElementById('pause-btn');
            const recordingIndicator = document.getElementById('recording-indicator');
            const recordingTimer = document.getElementById('recording-timer');
            const volumeMeter = document.getElementById('volume-meter');
            
            if (isRecording) {
                // Stop recording
                isRecording = false;
                isPaused = false;
                recordBtn.textContent = 'Start Recording';
                recordBtn.classList.replace('btn-secondary', 'btn-danger');
                pauseBtn.disabled = true;
                recordingIndicator.style.display = 'none';
                recordingTimer.style.display = 'none';
                volumeMeter.style.display = 'none';
                
                // Stop timer
                clearInterval(recordingTimer);
                
                // Stop mouse tracking
                clearInterval(mouseTrackingInterval);
                
                // Stop audio recording
                if (recorder) {
                    recorder.stopRecording(function() {
                        audioBlob = recorder.getBlob();
                        logMessage(`Audio recording completed: ${Math.round(audioBlob.size / 1024)} KB`);
                    });
                }
                
                if (audioStream) {
                    audioStream.getTracks().forEach(track => track.stop());
                    audioStream = null;
                }
                
                if (audioContext) {
                    audioContext.close();
                    audioContext = null;
                }
                
                logMessage(`Recording stopped. Captured ${mouseData.length} mouse positions.`);
            } else {
                // Start recording
                isRecording = true;
                isPaused = false;
                pausedTime = 0;
                recordBtn.textContent = 'Stop Recording';
                recordBtn.classList.replace('btn-danger', 'btn-secondary');
                pauseBtn.disabled = false;
                pauseBtn.textContent = 'Pause Recording';
                recordingIndicator.style.display = 'inline';
                recordingIndicator.style.color = 'red';
                recordingTimer.style.display = 'inline';
                volumeMeter.style.display = 'block';
                
                // Reset data
                mouseData = [];
                audioBlob = null;
                recordingStartTime = Date.now();
                
                // Start recording timer
                recordingTimer.textContent = '00:00';
                recordingTimer = setInterval(updateRecordingTimer, 1000);
                
                // Start mouse tracking (5 times per second)
                mouseTrackingInterval = setInterval(function() {
                    if (isPaused) return;
                    
                    const pointer = canvas.getPointer({ e: canvas.upperCanvasEl });
                    mouseData.push({
                        timestamp: Date.now(),
                        x: pointer.x,
                        y: pointer.y,
                        isDown: canvas.isDrawingMode ? canvas.isDrawing : false
                    });
                }, 200); // 5 times per second = 200ms
                
                // Start audio recording
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(function(stream) {
                        audioStream = stream;
                        
                        // Create audio context for volume meter
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const source = audioContext.createMediaStreamSource(stream);
                        const analyser = audioContext.createAnalyser();
                        analyser.fftSize = 256;
                        source.connect(analyser);
                        
                        // Start volume meter
                        const volumeLevel = document.getElementById('volume-level');
                        const dataArray = new Uint8Array(analyser.frequencyBinCount);
                        
                        function updateVolumeMeter() {
                            if (!isRecording) return;
                            
                            analyser.getByteFrequencyData(dataArray);
                            let sum = 0;
                            for (let i = 0; i < dataArray.length; i++) {
                                sum += dataArray[i];
                            }
                            const average = sum / dataArray.length;
                            const percentage = (average / 255) * 100;
                            
                            volumeLevel.style.width = `${percentage}%`;
                            requestAnimationFrame(updateVolumeMeter);
                        }
                        
                        updateVolumeMeter();
                        
                        // Start recording
                        recorder = RecordRTC(stream, {
                            type: 'audio',
                            mimeType: 'audio/webm',
                            recorderType: RecordRTC.StereoAudioRecorder,
                            disableLogs: true
                        });
                        recorder.startRecording();
                        
                        logMessage('Audio recording started');
                    })
                    .catch(function(error) {
                        console.error('Error accessing microphone:', error);
                        alert('Error accessing microphone. Please check your permissions.');
                        logMessage('Error accessing microphone: ' + error.message);
                        
                        // Stop recording if microphone fails
                        isRecording = false;
                        recordBtn.textContent = 'Start Recording';
                        recordBtn.classList.replace('btn-secondary', 'btn-danger');
                        pauseBtn.disabled = true;
                        recordingIndicator.style.display = 'none';
                        recordingTimer.style.display = 'none';
                        volumeMeter.style.display = 'none';
                        
                        clearInterval(mouseTrackingInterval);
                    });
                
                logMessage('Recording started');
            }
        }

        function updateRecordingTimer() {
            if (!isRecording) return;
            
            let elapsedMilliseconds = Date.now() - recordingStartTime - pausedTime;
            if (isPaused) {
                elapsedMilliseconds = Date.now() - recordingStartTime - pausedTime;
            }
            
            const elapsedSeconds = Math.floor(elapsedMilliseconds / 1000);
            const minutes = Math.floor(elapsedSeconds / 60).toString().padStart(2, '0');
            const seconds = (elapsedSeconds % 60).toString().padStart(2, '0');
            
            document.getElementById('recording-timer').textContent = `${minutes}:${seconds}`;
        }

        function saveAnnotationData() {
            // Create canvas snapshot
            const canvasData = canvas.toJSON();
            
            // Create data object
            const annotationData = {
                canvasData: canvasData,
                mouseData: mouseData,
                hasAudio: audioBlob !== null,
                timestamp: new Date().toISOString()
            };
            
            // Convert to JSON
            const jsonData = JSON.stringify(annotationData);
            
            // Save JSON file
            const jsonBlob = new Blob([jsonData], { type: 'application/json' });
            saveAs(jsonBlob, 'annotation_data.json');
            
            // Save audio if available
            if (audioBlob) {
                saveAs(audioBlob, 'annotation_audio.webm');
            }
            
            logMessage(`Annotation data saved. Objects: ${canvasData.objects.length}, Mouse positions: ${mouseData.length}, Audio: ${audioBlob ? 'Yes' : 'No'}`);
        }

        function loadAnnotationData(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // Load canvas data
                        canvas.loadFromJSON(data.canvasData, function() {
                            // Make sure all annotations are on top of the image
                            const image = canvas.getObjects().find(obj => obj.type === 'image');
                            if (image) {
                                image.sendToBack();
                            }
                            
                            canvas.renderAll();
                            logMessage(`Loaded annotation data. Objects: ${canvas.getObjects().length}`);
                        });
                        
                        // Load mouse data
                        mouseData = data.mouseData || [];
                        logMessage(`Loaded ${mouseData.length} mouse positions from file`);
                        
                        alert('Annotation data loaded successfully.');
                    } catch (error) {
                        console.error('Error loading annotation data:', error);
                        alert('Error loading annotation data. Please check the file format.');
                        logMessage(`Error loading annotation data: ${error.message}`);
                    }
                };
                reader.readAsText(file);
            }
        }

        function replayRecording() {
            if (mouseData.length === 0) {
                alert('No recording data available to replay.');
                logMessage('Replay failed: No mouse data available');
                return;
            }
            
            logMessage(`Replaying recording with ${mouseData.length} frames`);
            
            // Create indicator dot
            const dot = new fabric.Circle({
                left: 0,
                top: 0,
                radius: cursorSize / 2,
                fill: 'red',
                originX: 'center',
                originY: 'center',
                selectable: false,
                id: 'cursor'
            });
            canvas.add(dot);
            dot.bringToFront();
            
            // Create trail elements
            const trail = new fabric.Path('', {
                stroke: 'rgba(255, 0, 0, 0.3)',
                strokeWidth: 2,
                fill: false,
                selectable: false,
                id: 'replayTrail'
            });
            canvas.add(trail);
            trail.bringToFront();
            
            let pathData = [];
            let index = 0;
            
            function playNextFrame() {
                if (index >= mouseData.length) {
                    setTimeout(() => {
                        canvas.remove(dot);
                        canvas.remove(trail);
                        canvas.renderAll();
                        logMessage('Replay completed');
                    }, 1000);
                    return;
                }
                
                const frame = mouseData[index];
                dot.set({
                    left: frame.x,
                    top: frame.y
                });
                
                // Update trail path
                if (index === 0) {
                    pathData = ['M', frame.x, frame.y];
                } else {
                    pathData.push('L', frame.x, frame.y);
                }
                
                // Only keep the last 3 seconds of trail
                const trailLength = Math.min(15, index); // About 3 seconds at 5 fps
                if (index > trailLength) {
                    const startIndex = (index - trailLength) * 3; // Each point is 3 elements (M/L, x, y)
                    pathData = ['M', ...pathData.slice(startIndex + 1)];
                }
                
                trail.set({ path: pathData.join(' ') });
                canvas.renderAll();
                
                index++;
                
                // Calculate delay for next frame
                const nextDelay = index < mouseData.length ? 
                    mouseData[index].timestamp - mouseData[index - 1].timestamp : 0;
                
                setTimeout(playNextFrame, nextDelay);
            }
            
            playNextFrame();
        }

        function showEmailModal() {
            emailModal.show();
        }

        function sendEmail() {
            const email = document.getElementById('email-address').value;
            if (!email) {
                alert('Please enter an email address.');
                return;
            }
            
            // Save data first
            const canvasData = canvas.toJSON();
            const annotationData = {
                canvasData: canvasData,
                mouseData: mouseData,
                hasAudio: audioBlob !== null,
                timestamp: new Date().toISOString()
            };
            
            // Convert to JSON
            const jsonData = JSON.stringify(annotationData);
            
            // For demonstration, we'll use EmailJS
            // In a real application, you'd want to set up EmailJS with your service ID, template ID, and user ID
            alert('Email functionality would require server-side implementation or Email service configuration. The data has been prepared but not sent.');
            
            // Close modal
            emailModal.hide();
        }

        function pauseResumeRecording() {
            if (!isRecording) return;
            
            const pauseBtn = document.getElementById('pause-btn');
            const recordingIndicator = document.getElementById('recording-indicator');
            
            if (isPaused) {
                // Resume recording
                isPaused = false;
                pauseBtn.textContent = 'Pause Recording';
                recordingIndicator.style.color = 'red';
                
                // Calculate paused duration
                pausedTime += Date.now() - pauseStartTime;
                
                // Resume audio recording if available
                if (recorder) {
                    recorder.resumeRecording();
                }
                
                logMessage('Recording resumed');
            } else {
                // Pause recording
                isPaused = true;
                pauseBtn.textContent = 'Resume Recording';
                recordingIndicator.style.color = 'orange';
                pauseStartTime = Date.now();
                
                // Pause audio recording if available
                if (recorder) {
                    recorder.pauseRecording();
                }
                
                logMessage('Recording paused');
            }
        }

        function placeDot(options) {
            if (options.e.ctrlKey) return; // Don't place dot if ctrl is pressed (panning)
            
            const pointer = canvas.getPointer(options.e);
            
            // Create dot
            const dot = new fabric.Circle({
                left: pointer.x,
                top: pointer.y,
                radius: cursorSize / 2,
                fill: '#000000',
                stroke: '#000000',
                strokeWidth: 1,
                originX: 'center',
                originY: 'center',
                selectable: true
            });
            
            canvas.add(dot);
            dot.bringToFront();
            canvas.renderAll();
            
            logMessage(`Dot placed at X: ${Math.round(pointer.x)}, Y: ${Math.round(pointer.y)}`);
        }
    </script>
</body>
</html> 